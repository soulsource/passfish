/* generated by rust_qt_binding_generator */
/* Beware: a lot of const pointers mentioned in this file are mutating data on the Rust side. */
#include "Bindings.h"

namespace {

    struct option_quint32 {
    public:
        quint32 value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_quint32>::value, "option_quint32 must be a POD type.");

    struct option_quintptr {
    public:
        quintptr value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_quintptr>::value, "option_quintptr must be a POD type.");

    typedef void (*qstring_set)(QString* val, const char* utf8, int nbytes);
    void set_qstring(QString* val, const char* utf8, int nbytes) {
        *val = QString::fromUtf8(utf8, nbytes);
    }

    struct qmodelindex_t {
        int row;
        quintptr id;
    };
    inline QVariant cleanNullQVariant(const QVariant& v) {
        return (v.isNull()) ?QVariant() :v;
    }
    inline void passwordMakerGenerated_passwordChanged(PasswordMaker* o)
    {
        Q_EMIT o->generated_passwordChanged();
    }
    inline void passwordMakerGenerator_stateChanged(PasswordMaker* o)
    {
        Q_EMIT o->generator_stateChanged();
    }
    inline void passwordMakerI_say_sexy_things_to_myself_while_im_dancingChanged(PasswordMaker* o)
    {
        Q_EMIT o->i_say_sexy_things_to_myself_while_im_dancingChanged();
    }
    inline void passwordMakerMaster_passwordChanged(PasswordMaker* o)
    {
        Q_EMIT o->master_passwordChanged();
    }
    inline void passwordMakerUrlChanged(PasswordMaker* o)
    {
        Q_EMIT o->urlChanged();
    }
    inline void passwordMakerUsed_textChanged(PasswordMaker* o)
    {
        Q_EMIT o->used_textChanged();
    }
    inline void profilesCurrent_profileChanged(Profiles* o)
    {
        Q_EMIT o->current_profileChanged();
    }
    inline void profilesCurrent_profile_nameChanged(Profiles* o)
    {
        Q_EMIT o->current_profile_nameChanged();
    }
    inline void settingsClear_generated_password_secondsChanged(Settings* o)
    {
        Q_EMIT o->clear_generated_password_secondsChanged();
    }
    inline void settingsClear_master_password_secondsChanged(Settings* o)
    {
        Q_EMIT o->clear_master_password_secondsChanged();
    }
    inline void settingsHide_generated_passwordChanged(Settings* o)
    {
        Q_EMIT o->hide_generated_passwordChanged();
    }
}
extern "C" {
    PasswordMaker::Private* password_maker_new(PasswordMaker*, void (*)(PasswordMaker*), void (*)(PasswordMaker*), void (*)(PasswordMaker*), void (*)(PasswordMaker*), Profiles*, void (*)(Profiles*), void (*)(Profiles*),
        void (*)(const Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*, quintptr, quintptr),
        void (*)(Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int, int),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int),
        void (*)(Profiles*), Settings*, void (*)(Settings*), void (*)(Settings*), void (*)(Settings*), void (*)(PasswordMaker*), void (*)(PasswordMaker*));
    void password_maker_free(PasswordMaker::Private*);
    void password_maker_generated_password_get(const PasswordMaker::Private*, QString*, qstring_set);
    quint8 password_maker_generator_state_get(const PasswordMaker::Private*);
    bool password_maker_i_say_sexy_things_to_myself_while_im_dancing_get(const PasswordMaker::Private*);
    void password_maker_i_say_sexy_things_to_myself_while_im_dancing_set(const PasswordMaker::Private*, bool);
    void password_maker_master_password_get(const PasswordMaker::Private*, QString*, qstring_set);
    void password_maker_master_password_set(const PasswordMaker::Private*, const ushort *str, int len);
    const Profiles::Private* password_maker_profiles_get(const PasswordMaker::Private*);
    const Settings::Private* password_maker_settings_get(const PasswordMaker::Private*);
    void password_maker_url_get(const PasswordMaker::Private*, QString*, qstring_set);
    void password_maker_url_set(const PasswordMaker::Private*, const ushort *str, int len);
    void password_maker_used_text_get(const PasswordMaker::Private*, QString*, qstring_set);
    void password_maker_used_text_set(const PasswordMaker::Private*, const ushort *str, int len);
    void password_maker_profile_changed(const PasswordMaker::Private*);
    bool password_maker_store_settings(const PasswordMaker::Private*);
};

extern "C" {
    void profiles_data_characters(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_characters(const Profiles::Private*, int, const ushort* s, int len);
    quint8 profiles_data_hash_algorithm(const Profiles::Private*, int);
    bool profiles_set_data_hash_algorithm(const Profiles::Private*, int, quint8);
    quint8 profiles_data_leet_level(const Profiles::Private*, int);
    bool profiles_set_data_leet_level(const Profiles::Private*, int, quint8);
    void profiles_data_modifier(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_modifier(const Profiles::Private*, int, const ushort* s, int len);
    void profiles_data_name(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_name(const Profiles::Private*, int, const ushort* s, int len);
    quint32 profiles_data_password_length(const Profiles::Private*, int);
    bool profiles_set_data_password_length(const Profiles::Private*, int, quint32);
    void profiles_data_prefix(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_prefix(const Profiles::Private*, int, const ushort* s, int len);
    void profiles_data_suffix(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_suffix(const Profiles::Private*, int, const ushort* s, int len);
    bool profiles_data_use_domain(const Profiles::Private*, int);
    bool profiles_set_data_use_domain(const Profiles::Private*, int, bool);
    quint8 profiles_data_use_leet(const Profiles::Private*, int);
    bool profiles_set_data_use_leet(const Profiles::Private*, int, quint8);
    bool profiles_data_use_port_path(const Profiles::Private*, int);
    bool profiles_set_data_use_port_path(const Profiles::Private*, int, bool);
    bool profiles_data_use_protocol(const Profiles::Private*, int);
    bool profiles_set_data_use_protocol(const Profiles::Private*, int, bool);
    bool profiles_data_use_subdomains(const Profiles::Private*, int);
    bool profiles_set_data_use_subdomains(const Profiles::Private*, int, bool);
    bool profiles_data_use_undefined_as_protocol_fallback(const Profiles::Private*, int);
    bool profiles_set_data_use_undefined_as_protocol_fallback(const Profiles::Private*, int, bool);
    bool profiles_data_use_user_info(const Profiles::Private*, int);
    bool profiles_set_data_use_user_info(const Profiles::Private*, int, bool);
    void profiles_data_username(const Profiles::Private*, int, QString*, qstring_set);
    bool profiles_set_data_username(const Profiles::Private*, int, const ushort* s, int len);
    void profiles_sort(const Profiles::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int profiles_row_count(const Profiles::Private*);
    bool profiles_insert_rows(const Profiles::Private*, int, int);
    bool profiles_remove_rows(const Profiles::Private*, int, int);
    bool profiles_can_fetch_more(const Profiles::Private*);
    void profiles_fetch_more(const Profiles::Private*);
}
int Profiles::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 16;
}

bool Profiles::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int Profiles::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : profiles_row_count(m_d);
}

bool Profiles::insertRows(int row, int count, const QModelIndex &)
{
    return profiles_insert_rows(m_d, row, count);
}

bool Profiles::removeRows(int row, int count, const QModelIndex &)
{
    return profiles_remove_rows(m_d, row, count);
}

QModelIndex Profiles::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < 16) {
        return createIndex(row, column, (quintptr)row);
    }
    return QModelIndex();
}

QModelIndex Profiles::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool Profiles::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : profiles_can_fetch_more(m_d);
}

void Profiles::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        profiles_fetch_more(m_d);
    }
}
void Profiles::updatePersistentIndexes() {}

void Profiles::sort(int column, Qt::SortOrder order)
{
    profiles_sort(m_d, column, order);
}
Qt::ItemFlags Profiles::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    if (i.column() == 0) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 1) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 2) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 3) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 4) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 5) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 6) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 7) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 8) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 9) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 10) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 11) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 12) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 13) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 14) {
        flags |= Qt::ItemIsEditable;
    }
    if (i.column() == 15) {
        flags |= Qt::ItemIsEditable;
    }
    return flags;
}

QString Profiles::characters(int row) const
{
    QString s;
    profiles_data_characters(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setCharacters(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_characters(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

quint8 Profiles::hash_algorithm(int row) const
{
    return profiles_data_hash_algorithm(m_d, row);
}

bool Profiles::setHash_algorithm(int row, quint8 value)
{
    bool set = false;
    set = profiles_set_data_hash_algorithm(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

quint8 Profiles::leet_level(int row) const
{
    return profiles_data_leet_level(m_d, row);
}

bool Profiles::setLeet_level(int row, quint8 value)
{
    bool set = false;
    set = profiles_set_data_leet_level(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Profiles::modifier(int row) const
{
    QString s;
    profiles_data_modifier(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setModifier(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_modifier(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Profiles::name(int row) const
{
    QString s;
    profiles_data_name(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setName(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_name(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

quint32 Profiles::password_length(int row) const
{
    return profiles_data_password_length(m_d, row);
}

bool Profiles::setPassword_length(int row, quint32 value)
{
    bool set = false;
    set = profiles_set_data_password_length(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Profiles::prefix(int row) const
{
    QString s;
    profiles_data_prefix(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setPrefix(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_prefix(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Profiles::suffix(int row) const
{
    QString s;
    profiles_data_suffix(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setSuffix(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_suffix(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_domain(int row) const
{
    return profiles_data_use_domain(m_d, row);
}

bool Profiles::setUse_domain(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_domain(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

quint8 Profiles::use_leet(int row) const
{
    return profiles_data_use_leet(m_d, row);
}

bool Profiles::setUse_leet(int row, quint8 value)
{
    bool set = false;
    set = profiles_set_data_use_leet(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_port_path(int row) const
{
    return profiles_data_use_port_path(m_d, row);
}

bool Profiles::setUse_port_path(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_port_path(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_protocol(int row) const
{
    return profiles_data_use_protocol(m_d, row);
}

bool Profiles::setUse_protocol(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_protocol(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_subdomains(int row) const
{
    return profiles_data_use_subdomains(m_d, row);
}

bool Profiles::setUse_subdomains(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_subdomains(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_undefined_as_protocol_fallback(int row) const
{
    return profiles_data_use_undefined_as_protocol_fallback(m_d, row);
}

bool Profiles::setUse_undefined_as_protocol_fallback(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_undefined_as_protocol_fallback(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

bool Profiles::use_user_info(int row) const
{
    return profiles_data_use_user_info(m_d, row);
}

bool Profiles::setUse_user_info(int row, bool value)
{
    bool set = false;
    set = profiles_set_data_use_user_info(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Profiles::username(int row) const
{
    QString s;
    profiles_data_username(m_d, row, &s, set_qstring);
    return s;
}

bool Profiles::setUsername(int row, const QString& value)
{
    bool set = false;
    set = profiles_set_data_username(m_d, row, value.utf16(), value.length());
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QVariant Profiles::data(const QModelIndex &index, int role) const
{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::UserRole + 0:
            return QVariant::fromValue(characters(index.row()));
        case Qt::UserRole + 1:
            return QVariant::fromValue(hash_algorithm(index.row()));
        case Qt::UserRole + 2:
            return QVariant::fromValue(leet_level(index.row()));
        case Qt::UserRole + 3:
            return QVariant::fromValue(modifier(index.row()));
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 4:
            return QVariant::fromValue(name(index.row()));
        case Qt::UserRole + 5:
            return QVariant::fromValue(password_length(index.row()));
        case Qt::UserRole + 6:
            return QVariant::fromValue(prefix(index.row()));
        case Qt::UserRole + 7:
            return QVariant::fromValue(suffix(index.row()));
        case Qt::UserRole + 8:
            return QVariant::fromValue(use_domain(index.row()));
        case Qt::UserRole + 9:
            return QVariant::fromValue(use_leet(index.row()));
        case Qt::UserRole + 10:
            return QVariant::fromValue(use_port_path(index.row()));
        case Qt::UserRole + 11:
            return QVariant::fromValue(use_protocol(index.row()));
        case Qt::UserRole + 12:
            return QVariant::fromValue(use_subdomains(index.row()));
        case Qt::UserRole + 13:
            return QVariant::fromValue(use_undefined_as_protocol_fallback(index.row()));
        case Qt::UserRole + 14:
            return QVariant::fromValue(use_user_info(index.row()));
        case Qt::UserRole + 15:
            return QVariant::fromValue(username(index.row()));
        }
        break;
    case 1:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 11:
            return QVariant::fromValue(use_protocol(index.row()));
        }
        break;
    case 2:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 12:
            return QVariant::fromValue(use_subdomains(index.row()));
        }
        break;
    case 3:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 8:
            return QVariant::fromValue(use_domain(index.row()));
        }
        break;
    case 4:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 10:
            return QVariant::fromValue(use_port_path(index.row()));
        }
        break;
    case 5:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 14:
            return QVariant::fromValue(use_user_info(index.row()));
        }
        break;
    case 6:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 13:
            return QVariant::fromValue(use_undefined_as_protocol_fallback(index.row()));
        }
        break;
    case 7:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 5:
            return QVariant::fromValue(password_length(index.row()));
        }
        break;
    case 8:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 1:
            return QVariant::fromValue(hash_algorithm(index.row()));
        }
        break;
    case 9:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 9:
            return QVariant::fromValue(use_leet(index.row()));
        }
        break;
    case 10:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 2:
            return QVariant::fromValue(leet_level(index.row()));
        }
        break;
    case 11:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 0:
            return QVariant::fromValue(characters(index.row()));
        }
        break;
    case 12:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 15:
            return QVariant::fromValue(username(index.row()));
        }
        break;
    case 13:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 3:
            return QVariant::fromValue(modifier(index.row()));
        }
        break;
    case 14:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 6:
            return QVariant::fromValue(prefix(index.row()));
        }
        break;
    case 15:
        switch (role) {
        case Qt::DisplayRole:
        case Qt::EditRole:
        case Qt::UserRole + 7:
            return QVariant::fromValue(suffix(index.row()));
        }
        break;
    }
    return QVariant();
}

int Profiles::role(const char* name) const {
    auto names = roleNames();
    auto i = names.constBegin();
    while (i != names.constEnd()) {
        if (i.value() == name) {
            return i.key();
        }
        ++i;
    }
    return -1;
}
QHash<int, QByteArray> Profiles::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "characters");
    names.insert(Qt::UserRole + 1, "hash_algorithm");
    names.insert(Qt::UserRole + 2, "leet_level");
    names.insert(Qt::UserRole + 3, "modifier");
    names.insert(Qt::UserRole + 4, "name");
    names.insert(Qt::UserRole + 5, "password_length");
    names.insert(Qt::UserRole + 6, "prefix");
    names.insert(Qt::UserRole + 7, "suffix");
    names.insert(Qt::UserRole + 8, "use_domain");
    names.insert(Qt::UserRole + 9, "use_leet");
    names.insert(Qt::UserRole + 10, "use_port_path");
    names.insert(Qt::UserRole + 11, "use_protocol");
    names.insert(Qt::UserRole + 12, "use_subdomains");
    names.insert(Qt::UserRole + 13, "use_undefined_as_protocol_fallback");
    names.insert(Qt::UserRole + 14, "use_user_info");
    names.insert(Qt::UserRole + 15, "username");
    return names;
}
QVariant Profiles::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation != Qt::Horizontal) {
        return QVariant();
    }
    return m_headerData.value(qMakePair(section, (Qt::ItemDataRole)role), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}

bool Profiles::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{
    if (orientation != Qt::Horizontal) {
        return false;
    }
    m_headerData.insert(qMakePair(section, (Qt::ItemDataRole)role), value);
    return true;
}

bool Profiles::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (index.column() == 0) {
        if (role == Qt::UserRole + 0) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setCharacters(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 1) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setHash_algorithm(index.row(), value.value<quint8>());
            }
        }
        if (role == Qt::UserRole + 2) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setLeet_level(index.row(), value.value<quint8>());
            }
        }
        if (role == Qt::UserRole + 3) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setModifier(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 4) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setName(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 5) {
            if (value.canConvert(qMetaTypeId<quint32>())) {
                return setPassword_length(index.row(), value.value<quint32>());
            }
        }
        if (role == Qt::UserRole + 6) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setPrefix(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 7) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setSuffix(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 8) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_domain(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 9) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setUse_leet(index.row(), value.value<quint8>());
            }
        }
        if (role == Qt::UserRole + 10) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_port_path(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 11) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_protocol(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 12) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_subdomains(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 13) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_undefined_as_protocol_fallback(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 14) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_user_info(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 15) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setUsername(index.row(), value.value<QString>());
            }
        }
    }
    if (index.column() == 1) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 11) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_protocol(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 2) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 12) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_subdomains(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 3) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 8) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_domain(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 4) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 10) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_port_path(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 5) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 14) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_user_info(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 6) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 13) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setUse_undefined_as_protocol_fallback(index.row(), value.value<bool>());
            }
        }
    }
    if (index.column() == 7) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 5) {
            if (value.canConvert(qMetaTypeId<quint32>())) {
                return setPassword_length(index.row(), value.value<quint32>());
            }
        }
    }
    if (index.column() == 8) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 1) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setHash_algorithm(index.row(), value.value<quint8>());
            }
        }
    }
    if (index.column() == 9) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 9) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setUse_leet(index.row(), value.value<quint8>());
            }
        }
    }
    if (index.column() == 10) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 2) {
            if (value.canConvert(qMetaTypeId<quint8>())) {
                return setLeet_level(index.row(), value.value<quint8>());
            }
        }
    }
    if (index.column() == 11) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 0) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setCharacters(index.row(), value.value<QString>());
            }
        }
    }
    if (index.column() == 12) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 15) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setUsername(index.row(), value.value<QString>());
            }
        }
    }
    if (index.column() == 13) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 3) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setModifier(index.row(), value.value<QString>());
            }
        }
    }
    if (index.column() == 14) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 6) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setPrefix(index.row(), value.value<QString>());
            }
        }
    }
    if (index.column() == 15) {
        if (role == Qt::DisplayRole || role == Qt::EditRole || role == Qt::UserRole + 7) {
            if (value.canConvert(qMetaTypeId<QString>())) {
                return setSuffix(index.row(), value.value<QString>());
            }
        }
    }
    return false;
}

extern "C" {
    Profiles::Private* profiles_new(Profiles*, void (*)(Profiles*), void (*)(Profiles*),
        void (*)(const Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*, quintptr, quintptr),
        void (*)(Profiles*),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int, int),
        void (*)(Profiles*),
        void (*)(Profiles*, int, int),
        void (*)(Profiles*));
    void profiles_free(Profiles::Private*);
    quint32 profiles_current_profile_get(const Profiles::Private*);
    void profiles_current_profile_set(const Profiles::Private*, quint32);
    void profiles_current_profile_name_get(const Profiles::Private*, QString*, qstring_set);
    bool profiles_store(const Profiles::Private*);
};

extern "C" {
    Settings::Private* settings_new(Settings*, void (*)(Settings*), void (*)(Settings*), void (*)(Settings*));
    void settings_free(Settings::Private*);
    option_quint32 settings_clear_generated_password_seconds_get(const Settings::Private*);
    void settings_clear_generated_password_seconds_set(const Settings::Private*, quint32);
    void settings_clear_generated_password_seconds_set_none(const Settings::Private*);
    option_quint32 settings_clear_master_password_seconds_get(const Settings::Private*);
    void settings_clear_master_password_seconds_set(const Settings::Private*, quint32);
    void settings_clear_master_password_seconds_set_none(const Settings::Private*);
    bool settings_hide_generated_password_get(const Settings::Private*);
    void settings_hide_generated_password_set(const Settings::Private*, bool);
};

PasswordMaker::PasswordMaker(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_profiles(new Profiles(false, this)),
    m_settings(new Settings(false, this)),
    m_d(nullptr),
    m_d_owned(nullptr)
{
}

PasswordMaker::PasswordMaker(QObject *parent):
    QObject(parent),
    m_profiles(new Profiles(false, this)),
    m_settings(new Settings(false, this)),
    m_d(nullptr),
    m_d_owned(password_maker_new(this,
        passwordMakerGenerated_passwordChanged,
        passwordMakerGenerator_stateChanged,
        passwordMakerI_say_sexy_things_to_myself_while_im_dancingChanged,
        passwordMakerMaster_passwordChanged, m_profiles,
        profilesCurrent_profileChanged,
        profilesCurrent_profile_nameChanged,
        [](const Profiles* o) {
            Q_EMIT o->newDataReady(QVariant());
        },
        [](Profiles* o) {
            Q_EMIT o->layoutAboutToBeChanged();
        },
        [](Profiles* o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
        },
        [](Profiles* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 15, last));
        },
        [](Profiles* o) {
            o->beginResetModel();
        },
        [](Profiles* o) {
            o->endResetModel();
        },
        [](Profiles* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](Profiles* o) {
            o->endInsertRows();
        },
        [](Profiles* o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(), destination);
        },
        [](Profiles* o) {
            o->endMoveRows();
        },
        [](Profiles* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](Profiles* o) {
            o->endRemoveRows();
        }
, m_settings,
        settingsClear_generated_password_secondsChanged,
        settingsClear_master_password_secondsChanged,
        settingsHide_generated_passwordChanged,
        passwordMakerUrlChanged,
        passwordMakerUsed_textChanged))
{
    m_d = m_d_owned;
    m_profiles->m_d = password_maker_profiles_get(m_d);
    m_settings->m_d = password_maker_settings_get(m_d);
    connect(this->m_profiles, &Profiles::newDataReady, this->m_profiles, [this](const QVariant& v) {
        this->m_profiles->fetchMore(QModelIndex());
    }, Qt::QueuedConnection);
}

PasswordMaker::~PasswordMaker() {
    if (m_d_owned) {
        password_maker_free(m_d_owned);
    }
}
QString PasswordMaker::generated_password() const
{
    QString v;
    password_maker_generated_password_get(m_d, &v, set_qstring);
    return v;
}
quint8 PasswordMaker::generator_state() const
{
    return password_maker_generator_state_get(m_d);
}
bool PasswordMaker::i_say_sexy_things_to_myself_while_im_dancing() const
{
    return password_maker_i_say_sexy_things_to_myself_while_im_dancing_get(m_d);
}
void PasswordMaker::setI_say_sexy_things_to_myself_while_im_dancing(bool v) {
    password_maker_i_say_sexy_things_to_myself_while_im_dancing_set(m_d, v);
}
QString PasswordMaker::master_password() const
{
    QString v;
    password_maker_master_password_get(m_d, &v, set_qstring);
    return v;
}
void PasswordMaker::setMaster_password(const QString& v) {
    password_maker_master_password_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
}
const Profiles* PasswordMaker::profiles() const
{
    return m_profiles;
}
Profiles* PasswordMaker::profiles()
{
    return m_profiles;
}
const Settings* PasswordMaker::settings() const
{
    return m_settings;
}
Settings* PasswordMaker::settings()
{
    return m_settings;
}
QString PasswordMaker::url() const
{
    QString v;
    password_maker_url_get(m_d, &v, set_qstring);
    return v;
}
void PasswordMaker::setUrl(const QString& v) {
    password_maker_url_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
}
QString PasswordMaker::used_text() const
{
    QString v;
    password_maker_used_text_get(m_d, &v, set_qstring);
    return v;
}
void PasswordMaker::setUsed_text(const QString& v) {
    password_maker_used_text_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
}
void PasswordMaker::profile_changed() const
{
    return password_maker_profile_changed(m_d);
}
bool PasswordMaker::store_settings() const
{
    return password_maker_store_settings(m_d);
}
Profiles::Profiles(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(nullptr),
    m_d_owned(nullptr)
{
    initHeaderData();
}

Profiles::Profiles(QObject *parent):
    QAbstractItemModel(parent),
    m_d(nullptr),
    m_d_owned(profiles_new(this,
        profilesCurrent_profileChanged,
        profilesCurrent_profile_nameChanged,
        [](const Profiles* o) {
            Q_EMIT o->newDataReady(QVariant());
        },
        [](Profiles* o) {
            Q_EMIT o->layoutAboutToBeChanged();
        },
        [](Profiles* o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
        },
        [](Profiles* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 15, last));
        },
        [](Profiles* o) {
            o->beginResetModel();
        },
        [](Profiles* o) {
            o->endResetModel();
        },
        [](Profiles* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](Profiles* o) {
            o->endInsertRows();
        },
        [](Profiles* o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(), destination);
        },
        [](Profiles* o) {
            o->endMoveRows();
        },
        [](Profiles* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](Profiles* o) {
            o->endRemoveRows();
        }
))
{
    m_d = m_d_owned;
    connect(this, &Profiles::newDataReady, this, [this](const QVariant& v) {
        this->fetchMore(QModelIndex());
    }, Qt::QueuedConnection);
    initHeaderData();
}

Profiles::~Profiles() {
    if (m_d_owned) {
        profiles_free(m_d_owned);
    }
}
void Profiles::initHeaderData() {
    m_headerData.insert(qMakePair(0, Qt::DisplayRole), QVariant("name"));
    m_headerData.insert(qMakePair(1, Qt::DisplayRole), QVariant("use_protocol"));
    m_headerData.insert(qMakePair(2, Qt::DisplayRole), QVariant("use_subdomains"));
    m_headerData.insert(qMakePair(3, Qt::DisplayRole), QVariant("use_domain"));
    m_headerData.insert(qMakePair(4, Qt::DisplayRole), QVariant("use_port_path"));
    m_headerData.insert(qMakePair(5, Qt::DisplayRole), QVariant("use_user_info"));
    m_headerData.insert(qMakePair(6, Qt::DisplayRole), QVariant("use_undefined_as_protocol_fallback"));
    m_headerData.insert(qMakePair(7, Qt::DisplayRole), QVariant("password_length"));
    m_headerData.insert(qMakePair(8, Qt::DisplayRole), QVariant("hash_algorithm"));
    m_headerData.insert(qMakePair(9, Qt::DisplayRole), QVariant("use_leet"));
    m_headerData.insert(qMakePair(10, Qt::DisplayRole), QVariant("leet_level"));
    m_headerData.insert(qMakePair(11, Qt::DisplayRole), QVariant("characters"));
    m_headerData.insert(qMakePair(12, Qt::DisplayRole), QVariant("username"));
    m_headerData.insert(qMakePair(13, Qt::DisplayRole), QVariant("modifier"));
    m_headerData.insert(qMakePair(14, Qt::DisplayRole), QVariant("prefix"));
    m_headerData.insert(qMakePair(15, Qt::DisplayRole), QVariant("suffix"));
}
quint32 Profiles::current_profile() const
{
    return profiles_current_profile_get(m_d);
}
void Profiles::setCurrent_profile(quint32 v) {
    profiles_current_profile_set(m_d, v);
}
QString Profiles::current_profile_name() const
{
    QString v;
    profiles_current_profile_name_get(m_d, &v, set_qstring);
    return v;
}
bool Profiles::store() const
{
    return profiles_store(m_d);
}
Settings::Settings(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_d_owned(nullptr)
{
}

Settings::Settings(QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_d_owned(settings_new(this,
        settingsClear_generated_password_secondsChanged,
        settingsClear_master_password_secondsChanged,
        settingsHide_generated_passwordChanged))
{
    m_d = m_d_owned;
}

Settings::~Settings() {
    if (m_d_owned) {
        settings_free(m_d_owned);
    }
}
QVariant Settings::clear_generated_password_seconds() const
{
    QVariant v;
    auto r = settings_clear_generated_password_seconds_get(m_d);
    if (r.some) {
        v.setValue(r.value);
    }
    return r;
}
void Settings::setClear_generated_password_seconds(const QVariant& v) {
    if (v.isNull() || !v.canConvert<quint32>()) {
        settings_clear_generated_password_seconds_set_none(m_d);
    } else {
        settings_clear_generated_password_seconds_set(m_d, v.value<quint32>());
    }
}
QVariant Settings::clear_master_password_seconds() const
{
    QVariant v;
    auto r = settings_clear_master_password_seconds_get(m_d);
    if (r.some) {
        v.setValue(r.value);
    }
    return r;
}
void Settings::setClear_master_password_seconds(const QVariant& v) {
    if (v.isNull() || !v.canConvert<quint32>()) {
        settings_clear_master_password_seconds_set_none(m_d);
    } else {
        settings_clear_master_password_seconds_set(m_d, v.value<quint32>());
    }
}
bool Settings::hide_generated_password() const
{
    return settings_hide_generated_password_get(m_d);
}
void Settings::setHide_generated_password(bool v) {
    settings_hide_generated_password_set(m_d, v);
}
